(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["graphology"] = factory();
	else
		root["graphology"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack://graphology/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/obliterator/chain.js":
/*!*******************************************!*\
  !*** ./node_modules/obliterator/chain.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterators.\n */\nvar Iterator = __webpack_require__(/*! ./iterator.js */ \"./node_modules/obliterator/iterator.js\");\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterators - Target iterators.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterators = arguments,\n      current,\n      i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterators.length)\n        return {done: true};\n\n      current = iterators[i];\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n\n\n//# sourceURL=webpack://graphology/./node_modules/obliterator/chain.js?");

/***/ }),

/***/ "./node_modules/obliterator/iterator.js":
/*!**********************************************!*\
  !*** ./node_modules/obliterator/iterator.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n\n  // Hiding the given function\n  Object.defineProperty(this, '_next', {\n    writable: false,\n    enumerable: false,\n    value: next\n  });\n\n  // Is the iterator complete?\n  this.done = false;\n}\n\n/**\n * Next function.\n *\n * @return {object}\n */\n// NOTE: maybe this should dropped for performance?\nIterator.prototype.next = function() {\n  if (this.done)\n    return {done: true};\n\n  var step = this._next();\n\n  if (step.done)\n    this.done = true;\n\n  return step;\n};\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function() {\n  var args = arguments,\n      l = args.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function() {\n  var iterator = new Iterator(null);\n  iterator.done = true;\n\n  return iterator;\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function(value) {\n  if (value instanceof Iterator)\n    return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n\n\n//# sourceURL=webpack://graphology/./node_modules/obliterator/iterator.js?");

/***/ }),

/***/ "./node_modules/obliterator/take.js":
/*!******************************************!*\
  !*** ./node_modules/obliterator/take.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\n\n/**\n * Take.\n *\n * @param  {Iterator} iterator - Target iterator.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterator, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n      array = l !== Infinity ? new Array(l) : [],\n      step,\n      i = 0;\n\n  while (true) {\n\n    if (i === l)\n      return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n\n      if (i !== n)\n        return array.slice(0, i);\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n\n\n//# sourceURL=webpack://graphology/./node_modules/obliterator/take.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack://graphology/(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./src/attributes.js":
/*!***************************!*\
  !*** ./src/attributes.js ***!
  \***************************/
/*! exports provided: attachAttributesMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachAttributesMethods\", function() { return attachAttributesMethods; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data */ \"./src/data.js\");\n/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\n\n\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\nfunction attachAttributeGetter(Class, method, type, EdgeDataClass) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 2) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + name;\n      name = arguments[2];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    return data.attributes[name];\n  };\n}\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\n\nfunction attachAttributesGetter(Class, method, type, EdgeDataClass) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 1) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + arguments[1];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    return data.attributes;\n  };\n}\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\n\nfunction attachAttributeChecker(Class, method, type, EdgeDataClass) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 2) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + name;\n      name = arguments[2];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\n\nfunction attachAttributeSetter(Class, method, type, EdgeDataClass) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 3) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + name;\n      name = arguments[2];\n      value = arguments[3];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    data.attributes[name] = value; // Emitting\n\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name: name,\n        value: value\n      }\n    });\n    return this;\n  };\n}\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\n\nfunction attachAttributeUpdater(Class, method, type, EdgeDataClass) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 3) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + name;\n      name = arguments[2];\n      updater = arguments[3];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (typeof updater !== 'function') throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(method, \": updater should be a function.\"));\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    data.attributes[name] = updater(data.attributes[name]); // Emitting\n\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name: name,\n        value: data.attributes[name]\n      }\n    });\n    return this;\n  };\n}\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\n\nfunction attachAttributeRemover(Class, method, type, EdgeDataClass) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 2) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + name;\n      name = arguments[2];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    delete data.attributes[name]; // Emitting\n\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      meta: {\n        name: name\n      }\n    });\n    return this;\n  };\n}\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\n\nfunction attachAttributesReplacer(Class, method, type, EdgeDataClass) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 2) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + attributes;\n      attributes = arguments[2];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(method, \": provided attributes are not a plain object.\"));\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    var oldAttributes = data.attributes;\n    data.attributes = attributes; // Emitting\n\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n    return this;\n  };\n}\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\n\n\nfunction attachAttributesMerger(Class, method, type, EdgeDataClass) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    var data;\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot find this type of edges in your \").concat(this.type, \" graph.\"));\n\n    if (arguments.length > 2) {\n      if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"UsageGraphError\"](\"Graph.\".concat(method, \": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.\"));\n      var source = '' + element,\n          target = '' + attributes;\n      attributes = arguments[2];\n      data = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getMatchingEdge\"])(this, source, target, type);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find an edge for the given path (\\\"\").concat(source, \"\\\" - \\\"\").concat(target, \"\\\").\"));\n    } else {\n      element = '' + element;\n      data = this._edges.get(element);\n      if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" edge in the graph.\"));\n    }\n\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(method, \": provided attributes are not a plain object.\"));\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass)) throw new _errors__WEBPACK_IMPORTED_MODULE_1__[\"NotFoundGraphError\"](\"Graph.\".concat(method, \": could not find the \\\"\").concat(element, \"\\\" \").concat(type, \" edge in the graph.\"));\n    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(data.attributes, attributes); // Emitting\n\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n    return this;\n  };\n}\n/**\n * List of methods to attach.\n */\n\n\nvar ATTRIBUTES_METHODS = [{\n  name: function name(element) {\n    return \"get\".concat(element, \"Attribute\");\n  },\n  attacher: attachAttributeGetter\n}, {\n  name: function name(element) {\n    return \"get\".concat(element, \"Attributes\");\n  },\n  attacher: attachAttributesGetter\n}, {\n  name: function name(element) {\n    return \"has\".concat(element, \"Attribute\");\n  },\n  attacher: attachAttributeChecker\n}, {\n  name: function name(element) {\n    return \"set\".concat(element, \"Attribute\");\n  },\n  attacher: attachAttributeSetter\n}, {\n  name: function name(element) {\n    return \"update\".concat(element, \"Attribute\");\n  },\n  attacher: attachAttributeUpdater\n}, {\n  name: function name(element) {\n    return \"remove\".concat(element, \"Attribute\");\n  },\n  attacher: attachAttributeRemover\n}, {\n  name: function name(element) {\n    return \"replace\".concat(element, \"Attributes\");\n  },\n  attacher: attachAttributesReplacer\n}, {\n  name: function name(element) {\n    return \"merge\".concat(element, \"Attributes\");\n  },\n  attacher: attachAttributesMerger\n}];\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\n\nfunction attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function (_ref) {\n    var name = _ref.name,\n        attacher = _ref.attacher;\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed', _data__WEBPACK_IMPORTED_MODULE_2__[\"DirectedEdgeData\"]); // For directed edges\n\n    attacher(Graph, name('DirectedEdge'), 'directed', _data__WEBPACK_IMPORTED_MODULE_2__[\"DirectedEdgeData\"]); // For undirected edges\n\n    attacher(Graph, name('UndirectedEdge'), 'undirected', _data__WEBPACK_IMPORTED_MODULE_2__[\"UndirectedEdgeData\"]);\n  });\n}\n\n//# sourceURL=webpack://graphology/./src/attributes.js?");

/***/ }),

/***/ "./src/data.js":
/*!*********************!*\
  !*** ./src/data.js ***!
  \*********************/
/*! exports provided: MixedNodeData, DirectedNodeData, UndirectedNodeData, DirectedEdgeData, UndirectedEdgeData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MixedNodeData\", function() { return MixedNodeData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectedNodeData\", function() { return DirectedNodeData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UndirectedNodeData\", function() { return UndirectedNodeData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectedEdgeData\", function() { return DirectedEdgeData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UndirectedEdgeData\", function() { return UndirectedEdgeData; });\n/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes; // Degrees\n\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0; // Indices\n\n  this[\"in\"] = {};\n  this.out = {};\n  this.undirected = {};\n}\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\n\nfunction DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {}; // Degrees\n\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0; // Indices\n\n  this[\"in\"] = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0; // Indices\n\n  this.undirected = {};\n};\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\n\n\nfunction UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {}; // Degrees\n\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0; // Indices\n\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0; // Indices\n\n  this[\"in\"] = {};\n  this.out = {};\n};\n/**\n * DirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\n\n\nfunction DirectedEdgeData(key, generatedKey, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes; // Extremities\n\n  this.source = source;\n  this.target = target; // Was its key generated?\n\n  this.generatedKey = generatedKey;\n}\n/**\n * UndirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\n\nfunction UndirectedEdgeData(key, generatedKey, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes; // Extremities\n\n  this.source = source;\n  this.target = target; // Was its key generated?\n\n  this.generatedKey = generatedKey;\n}\n\n//# sourceURL=webpack://graphology/./src/data.js?");

/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! exports provided: GraphError, InvalidArgumentsGraphError, NotFoundGraphError, UsageGraphError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GraphError\", function() { return GraphError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvalidArgumentsGraphError\", function() { return InvalidArgumentsGraphError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotFoundGraphError\", function() { return NotFoundGraphError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UsageGraphError\", function() { return UsageGraphError; });\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nvar GraphError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inheritsLoose(GraphError, _Error);\n\n  function GraphError(message, data) {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    _this.name = 'GraphError';\n    _this.message = message || '';\n    _this.data = data || {};\n    return _this;\n  }\n\n  return GraphError;\n}(_wrapNativeSuper(Error));\nvar InvalidArgumentsGraphError =\n/*#__PURE__*/\nfunction (_GraphError) {\n  _inheritsLoose(InvalidArgumentsGraphError, _GraphError);\n\n  function InvalidArgumentsGraphError(message, data) {\n    var _this2;\n\n    _this2 = _GraphError.call(this, message, data) || this;\n    _this2.name = 'InvalidArgumentsGraphError'; // This is V8 specific to enhance stack readability\n\n    if (typeof Error.captureStackTrace === 'function') Error.captureStackTrace(_assertThisInitialized(_this2), InvalidArgumentsGraphError.prototype.constructor);\n    return _this2;\n  }\n\n  return InvalidArgumentsGraphError;\n}(GraphError);\nvar NotFoundGraphError =\n/*#__PURE__*/\nfunction (_GraphError2) {\n  _inheritsLoose(NotFoundGraphError, _GraphError2);\n\n  function NotFoundGraphError(message, data) {\n    var _this3;\n\n    _this3 = _GraphError2.call(this, message, data) || this;\n    _this3.name = 'NotFoundGraphError'; // This is V8 specific to enhance stack readability\n\n    if (typeof Error.captureStackTrace === 'function') Error.captureStackTrace(_assertThisInitialized(_this3), NotFoundGraphError.prototype.constructor);\n    return _this3;\n  }\n\n  return NotFoundGraphError;\n}(GraphError);\nvar UsageGraphError =\n/*#__PURE__*/\nfunction (_GraphError3) {\n  _inheritsLoose(UsageGraphError, _GraphError3);\n\n  function UsageGraphError(message, data) {\n    var _this4;\n\n    _this4 = _GraphError3.call(this, message, data) || this;\n    _this4.name = 'UsageGraphError'; // This is V8 specific to enhance stack readability\n\n    if (typeof Error.captureStackTrace === 'function') Error.captureStackTrace(_assertThisInitialized(_this4), UsageGraphError.prototype.constructor);\n    return _this4;\n  }\n\n  return UsageGraphError;\n}(GraphError);\n\n//# sourceURL=webpack://graphology/./src/errors.js?");

/***/ }),

/***/ "./src/graph.js":
/*!**********************!*\
  !*** ./src/graph.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Graph; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var obliterator_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! obliterator/iterator */ \"./node_modules/obliterator/iterator.js\");\n/* harmony import */ var obliterator_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(obliterator_iterator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var obliterator_take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! obliterator/take */ \"./node_modules/obliterator/take.js\");\n/* harmony import */ var obliterator_take__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(obliterator_take__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data */ \"./src/data.js\");\n/* harmony import */ var _indices__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./indices */ \"./src/indices.js\");\n/* harmony import */ var _attributes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attributes */ \"./src/attributes.js\");\n/* harmony import */ var _iteration_edges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./iteration/edges */ \"./src/iteration/edges.js\");\n/* harmony import */ var _iteration_neighbors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./iteration/neighbors */ \"./src/iteration/neighbors.js\");\n/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./serialization */ \"./src/serialization.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/* eslint no-nested-ternary: 0 */\n\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Enums.\n */\n\nvar TYPES = new Set(['directed', 'undirected', 'mixed']);\nvar EMITTER_PROPS = new Set(['domain', '_events', '_eventsCount', '_maxListeners']);\nvar EDGE_ADD_METHODS = [{\n  name: function name(verb) {\n    return \"\".concat(verb, \"Edge\");\n  },\n  generateKey: true\n}, {\n  name: function name(verb) {\n    return \"\".concat(verb, \"DirectedEdge\");\n  },\n  generateKey: true,\n  type: 'directed'\n}, {\n  name: function name(verb) {\n    return \"\".concat(verb, \"UndirectedEdge\");\n  },\n  generateKey: true,\n  type: 'undirected'\n}, {\n  name: function name(verb) {\n    return \"\".concat(verb, \"EdgeWithKey\");\n  }\n}, {\n  name: function name(verb) {\n    return \"\".concat(verb, \"DirectedEdgeWithKey\");\n  },\n  type: 'directed'\n}, {\n  name: function name(verb) {\n    return \"\".concat(verb, \"UndirectedEdgeWithKey\");\n  },\n  type: 'undirected'\n}];\n/**\n * Default options.\n */\n\nvar DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\n\nfunction addEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.\"));\n  if (undirected && graph.type === 'directed') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.\"));\n  if (attributes && !Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(name, \": invalid attributes. Expecting an object but got \\\"\").concat(attributes, \"\\\"\")); // Coercion of source & target:\n\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n  if (!graph.allowSelfLoops && source === target) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": source & target are the same (\\\"\").concat(source, \"\\\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.\"));\n\n  var sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target);\n\n  if (!sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \": source node \\\"\").concat(source, \"\\\" not found.\"));\n  if (!targetData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \": target node \\\"\").concat(target, \"\\\" not found.\")); // Must the graph generate an id for this edge?\n\n  var eventData = {\n    key: null,\n    undirected: undirected,\n    source: source,\n    target: target,\n    attributes: attributes\n  };\n  if (mustGenerateKey) edge = graph._edgeKeyGenerator(eventData); // Coercion of edge key\n\n  edge = '' + edge; // Here, we have a key collision\n\n  if (graph._edges.has(edge)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": the \\\"\").concat(edge, \"\\\" edge already exists in the graph.\")); // Here, we might have a source / target collision\n\n  if (!graph.multi && (undirected ? typeof sourceData.undirected[target] !== 'undefined' : typeof sourceData.out[target] !== 'undefined')) {\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": an edge linking \\\"\").concat(source, \"\\\" to \\\"\").concat(target, \"\\\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.\"));\n  } // Storing some data\n\n\n  var DataClass = undirected ? _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"] : _data__WEBPACK_IMPORTED_MODULE_4__[\"DirectedEdgeData\"];\n  var edgeData = new DataClass(edge, mustGenerateKey, sourceData, targetData, attributes); // Adding the edge to the internal register\n\n  graph._edges.set(edge, edgeData); // Incrementing node degree counters\n\n\n  if (source === target) {\n    if (undirected) sourceData.undirectedSelfLoops++;else sourceData.directedSelfLoops++;\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  } // Updating relevant index\n\n\n  Object(_indices__WEBPACK_IMPORTED_MODULE_5__[\"updateStructureIndex\"])(graph, undirected, edgeData, source, target, sourceData, targetData);\n  if (undirected) graph._undirectedSize++;else graph._directedSize++; // Emitting\n\n  eventData.key = edge;\n  graph.emit('edgeAdded', eventData);\n  return edge;\n}\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\n\n\nfunction mergeEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.\"));\n  if (undirected && graph.type === 'directed') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.\"));\n  if (attributes && !Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(name, \": invalid attributes. Expecting an object but got \\\"\").concat(attributes, \"\\\"\")); // Coercion of source & target:\n\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n  if (!graph.allowSelfLoops && source === target) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": source & target are the same (\\\"\").concat(source, \"\\\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.\"));\n\n  var sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData; // Do we need to handle duplicate?\n\n\n  var alreadyExistingEdge = null;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (edgeData.source !== source || edgeData.target !== target || undirected && (edgeData.source !== target || edgeData.target !== source)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": inconsistency detected when attempting to merge the \\\"\").concat(edge, \"\\\" edge with \\\"\").concat(source, \"\\\" source & \\\"\").concat(target, \"\\\" target vs. (\").concat(edgeData.source, \", \").concat(edgeData.target, \").\"));\n      }\n\n      alreadyExistingEdge = edge;\n    }\n  }\n\n  var alreadyExistingEdgeData; // Here, we might have a source / target collision\n\n  if (!alreadyExistingEdge && !graph.multi && sourceData && (undirected ? typeof sourceData.undirected[target] !== 'undefined' : typeof sourceData.out[target] !== 'undefined')) {\n    alreadyExistingEdgeData = Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"getMatchingEdge\"])(graph, source, target, undirected ? 'undirected' : 'directed');\n  } // Handling duplicates\n\n\n  if (alreadyExistingEdgeData) {\n    // We can skip the attribute merging part if the user did not provide them\n    if (!attributes) return alreadyExistingEdge; // Merging the attributes\n\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])(alreadyExistingEdgeData.attributes, attributes);\n    return alreadyExistingEdge;\n  } // Must the graph generate an id for this edge?\n\n\n  var eventData = {\n    key: null,\n    undirected: undirected,\n    source: source,\n    target: target,\n    attributes: attributes\n  };\n  if (mustGenerateKey) edge = graph._edgeKeyGenerator(eventData); // Coercion of edge key\n\n  edge = '' + edge; // Here, we have a key collision\n\n  if (graph._edges.has(edge)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.\".concat(name, \": the \\\"\").concat(edge, \"\\\" edge already exists in the graph.\"));\n\n  if (!sourceData) {\n    graph.addNode(source);\n    sourceData = graph._nodes.get(source);\n    if (source === target) targetData = sourceData;\n  }\n\n  if (!targetData) {\n    graph.addNode(target);\n    targetData = graph._nodes.get(target);\n  } // Storing some data\n\n\n  var DataClass = undirected ? _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"] : _data__WEBPACK_IMPORTED_MODULE_4__[\"DirectedEdgeData\"];\n  edgeData = new DataClass(edge, mustGenerateKey, sourceData, targetData, attributes); // Adding the edge to the internal register\n\n  graph._edges.set(edge, edgeData); // Incrementing node degree counters\n\n\n  if (source === target) {\n    if (undirected) sourceData.undirectedSelfLoops++;else sourceData.directedSelfLoops++;\n  } else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    } else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  } // Updating relevant index\n\n\n  Object(_indices__WEBPACK_IMPORTED_MODULE_5__[\"updateStructureIndex\"])(graph, undirected, edgeData, source, target, sourceData, targetData);\n  if (undirected) graph._undirectedSize++;else graph._directedSize++; // Emitting\n\n  eventData.key = edge;\n  graph.emit('edgeAdded', eventData);\n  return edge;\n}\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\n\n\nvar Graph =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inheritsLoose(Graph, _EventEmitter);\n\n  function Graph(options) {\n    var _this;\n\n    _this = _EventEmitter.call(this) || this; //-- Solving options\n\n    options = Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])({}, DEFAULTS, options); // Enforcing options validity\n\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \\\"\".concat(options.edgeKeyGenerator, \"\\\".\"));\n    if (typeof options.multi !== 'boolean') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.constructor: invalid 'multi' option. Expecting a boolean but got \\\"\".concat(options.multi, \"\\\".\"));\n    if (!TYPES.has(options.type)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.constructor: invalid 'type' option. Should be one of \\\"mixed\\\", \\\"directed\\\" or \\\"undirected\\\" but got \\\"\".concat(options.type, \"\\\".\"));\n    if (typeof options.allowSelfLoops !== 'boolean') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \\\"\".concat(options.allowSelfLoops, \"\\\".\")); //-- Private properties\n    // Utilities\n\n    var NodeDataClass = options.type === 'mixed' ? _data__WEBPACK_IMPORTED_MODULE_4__[\"MixedNodeData\"] : options.type === 'directed' ? _data__WEBPACK_IMPORTED_MODULE_4__[\"DirectedNodeData\"] : _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedNodeData\"];\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), 'NodeDataClass', NodeDataClass); // Indexes\n\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), '_attributes', {});\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), '_nodes', new Map());\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), '_edges', new Map());\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), '_directedSize', 0);\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), '_undirectedSize', 0);\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), '_edgeKeyGenerator', options.edgeKeyGenerator || Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"incrementalId\"])()); // Options\n\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), '_options', options); // Emitter properties\n\n    EMITTER_PROPS.forEach(function (prop) {\n      return Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(_assertThisInitialized(_this), prop, _this[prop]);\n    }); //-- Properties readers\n\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(_assertThisInitialized(_this), 'order', function () {\n      return _this._nodes.size;\n    });\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(_assertThisInitialized(_this), 'size', function () {\n      return _this._edges.size;\n    });\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(_assertThisInitialized(_this), 'directedSize', function () {\n      return _this._directedSize;\n    });\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(_assertThisInitialized(_this), 'undirectedSize', function () {\n      return _this._undirectedSize;\n    });\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(_assertThisInitialized(_this), 'multi', _this._options.multi);\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(_assertThisInitialized(_this), 'type', _this._options.type);\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(_assertThisInitialized(_this), 'allowSelfLoops', _this._options.allowSelfLoops);\n    return _this;\n  }\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n\n\n  var _proto = Graph.prototype;\n\n  _proto.hasNode = function hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  ;\n\n  _proto.hasDirectedEdge = function hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      var edge = '' + source;\n\n      var edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"DirectedEdgeData\"];\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target; // If the node source or the target is not in the graph we break\n\n      var nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false; // Is there a directed edge pointing toward target?\n\n      var edges = nodeData.out[target];\n      if (!edges) return false;\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.hasDirectedEdge: invalid arity (\".concat(arguments.length, \", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"));\n  }\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  ;\n\n  _proto.hasUndirectedEdge = function hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      var edge = '' + source;\n\n      var edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"];\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target; // If the node source or the target is not in the graph we break\n\n      var nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false; // Is there a directed edge pointing toward target?\n\n      var edges = nodeData.undirected[target];\n      if (!edges) return false;\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.hasDirectedEdge: invalid arity (\".concat(arguments.length, \", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"));\n  }\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  ;\n\n  _proto.hasEdge = function hasEdge(source, target) {\n    if (arguments.length === 1) {\n      var edge = '' + source;\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target; // If the node source or the target is not in the graph we break\n\n      var nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false; // Is there a directed edge pointing toward target?\n\n      var edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n      if (!edges) edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n      if (!edges) return false;\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.hasEdge: invalid arity (\".concat(arguments.length, \", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.\"));\n  }\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  ;\n\n  _proto.directedEdge = function directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n    source = '' + source;\n    target = '' + target;\n    if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"]('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    var sourceData = this._nodes.get(source);\n\n    if (!sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.directedEdge: could not find the \\\"\".concat(source, \"\\\" source node in the graph.\"));\n    if (!this._nodes.has(target)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.directedEdge: could not find the \\\"\".concat(target, \"\\\" target node in the graph.\"));\n    var edgeData = sourceData.out && sourceData.out[target] || undefined;\n    if (edgeData) return edgeData.key;\n  }\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  ;\n\n  _proto.undirectedEdge = function undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n    source = '' + source;\n    target = '' + target;\n    if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"]('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    var sourceData = this._nodes.get(source);\n\n    if (!sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.undirectedEdge: could not find the \\\"\".concat(source, \"\\\" source node in the graph.\"));\n    if (!this._nodes.has(target)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.undirectedEdge: could not find the \\\"\".concat(target, \"\\\" target node in the graph.\"));\n    var edgeData = sourceData.undirected && sourceData.undirected[target] || undefined;\n    if (edgeData) return edgeData.key;\n  }\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  ;\n\n  _proto.edge = function edge(source, target) {\n    if (this.multi) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"]('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n    source = '' + source;\n    target = '' + target;\n\n    var sourceData = this._nodes.get(source);\n\n    if (!sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.edge: could not find the \\\"\".concat(source, \"\\\" source node in the graph.\"));\n    if (!this._nodes.has(target)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.edge: could not find the \\\"\".concat(target, \"\\\" target node in the graph.\"));\n    var edgeData = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target] || undefined;\n    if (edgeData) return edgeData.key;\n  }\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  ;\n\n  _proto.inDegree = function inDegree(node) {\n    var selfLoops = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof selfLoops !== 'boolean') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.inDegree: Expecting a boolean but got \\\"\".concat(selfLoops, \"\\\" for the second parameter (allowing self-loops to be counted).\"));\n    node = '' + node;\n\n    var nodeData = this._nodes.get(node);\n\n    if (!nodeData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.inDegree: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (this.type === 'undirected') return 0;\n    var loops = selfLoops ? nodeData.directedSelfLoops : 0;\n    return nodeData.inDegree + loops;\n  }\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  ;\n\n  _proto.outDegree = function outDegree(node) {\n    var selfLoops = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof selfLoops !== 'boolean') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.outDegree: Expecting a boolean but got \\\"\".concat(selfLoops, \"\\\" for the second parameter (allowing self-loops to be counted).\"));\n    node = '' + node;\n\n    var nodeData = this._nodes.get(node);\n\n    if (!nodeData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.outDegree: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (this.type === 'undirected') return 0;\n    var loops = selfLoops ? nodeData.directedSelfLoops : 0;\n    return nodeData.outDegree + loops;\n  }\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  ;\n\n  _proto.directedDegree = function directedDegree(node) {\n    var selfLoops = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof selfLoops !== 'boolean') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.directedDegree: Expecting a boolean but got \\\"\".concat(selfLoops, \"\\\" for the second parameter (allowing self-loops to be counted).\"));\n    node = '' + node;\n    if (!this.hasNode(node)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.directedDegree: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (this.type === 'undirected') return 0;\n    return this.inDegree(node, selfLoops) + this.outDegree(node, selfLoops);\n  }\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  ;\n\n  _proto.undirectedDegree = function undirectedDegree(node) {\n    var selfLoops = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof selfLoops !== 'boolean') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.undirectedDegree: Expecting a boolean but got \\\"\".concat(selfLoops, \"\\\" for the second parameter (allowing self-loops to be counted).\"));\n    node = '' + node;\n    if (!this.hasNode(node)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.undirectedDegree: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (this.type === 'directed') return 0;\n\n    var data = this._nodes.get(node),\n        loops = selfLoops ? data.undirectedSelfLoops * 2 : 0;\n\n    return data.undirectedDegree + loops;\n  }\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  ;\n\n  _proto.degree = function degree(node) {\n    var selfLoops = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof selfLoops !== 'boolean') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.degree: Expecting a boolean but got \\\"\".concat(selfLoops, \"\\\" for the second parameter (allowing self-loops to be counted).\"));\n    node = '' + node;\n    if (!this.hasNode(node)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.degree: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    var degree = 0;\n    if (this.type !== 'undirected') degree += this.directedDegree(node, selfLoops);\n    if (this.type !== 'directed') degree += this.undirectedDegree(node, selfLoops);\n    return degree;\n  }\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  ;\n\n  _proto.source = function source(edge) {\n    edge = '' + edge;\n\n    var data = this._edges.get(edge);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.source: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    return data.source.key;\n  }\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  ;\n\n  _proto.target = function target(edge) {\n    edge = '' + edge;\n\n    var data = this._edges.get(edge);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.target: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    return data.target.key;\n  }\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  ;\n\n  _proto.extremities = function extremities(edge) {\n    edge = '' + edge;\n\n    var edgeData = this._edges.get(edge);\n\n    if (!edgeData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.extremities: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    return [edgeData.source.key, edgeData.target.key];\n  }\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  ;\n\n  _proto.opposite = function opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n    if (!this._nodes.has(node)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.opposite: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n\n    var data = this._edges.get(edge);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.opposite: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    var sourceData = data.source,\n        targetData = data.target;\n    var source = sourceData.key,\n        target = targetData.key;\n    if (node !== source && node !== target) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.opposite: the \\\"\".concat(node, \"\\\" node is not attached to the \\\"\").concat(edge, \"\\\" edge (\").concat(source, \", \").concat(target, \").\"));\n    return node === source ? target : source;\n  }\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  ;\n\n  _proto.undirected = function undirected(edge) {\n    edge = '' + edge;\n\n    var data = this._edges.get(edge);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.undirected: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    return data instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"];\n  }\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  ;\n\n  _proto.directed = function directed(edge) {\n    edge = '' + edge;\n\n    var data = this._edges.get(edge);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.directed: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    return data instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"DirectedEdgeData\"];\n  }\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  ;\n\n  _proto.selfLoop = function selfLoop(edge) {\n    edge = '' + edge;\n\n    var data = this._edges.get(edge);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.selfLoop: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    return data.source === data.target;\n  }\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  ;\n\n  _proto.addNode = function addNode(node, attributes) {\n    if (attributes && !Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.addNode: invalid attributes. Expecting an object but got \\\"\".concat(attributes, \"\\\"\")); // String coercion\n\n    node = '' + node;\n    attributes = attributes || {};\n    if (this._nodes.has(node)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"UsageGraphError\"](\"Graph.addNode: the \\\"\".concat(node, \"\\\" node already exist in the graph.\"));\n    var data = new this.NodeDataClass(node, attributes); // Adding the node to internal register\n\n    this._nodes.set(node, data); // Emitting\n\n\n    this.emit('nodeAdded', {\n      key: node,\n      attributes: attributes\n    });\n    return node;\n  }\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  ;\n\n  _proto.mergeNode = function mergeNode(node, attributes) {\n    if (attributes && !Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.mergeNode: invalid attributes. Expecting an object but got \\\"\".concat(attributes, \"\\\"\")); // String coercion\n\n    node = '' + node;\n    attributes = attributes || {}; // If the node already exists, we merge the attributes\n\n    var data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])(data.attributes, attributes);\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes); // Adding the node to internal register\n\n    this._nodes.set(node, data); // Emitting\n\n\n    this.emit('nodeAdded', {\n      key: node,\n      attributes: attributes\n    });\n    return node;\n  }\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  ;\n\n  _proto.dropNode = function dropNode(node) {\n    node = '' + node;\n    if (!this.hasNode(node)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.dropNode: could not find the \\\"\".concat(node, \"\\\" node in the graph.\")); // Removing attached edges\n\n    var edges = this.edges(node); // NOTE: we could go faster here\n\n    for (var i = 0, l = edges.length; i < l; i++) {\n      this.dropEdge(edges[i]);\n    }\n\n    var data = this._nodes.get(node); // Dropping the node from the register\n\n\n    this._nodes[\"delete\"](node); // Emitting\n\n\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: data.attributes\n    });\n  }\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  ;\n\n  _proto.dropEdge = function dropEdge(edge) {\n    var edgeData;\n\n    if (arguments.length > 1) {\n      var source = '' + arguments[0],\n          target = '' + arguments[1];\n      edgeData = Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"getMatchingEdge\"])(this, source, target, this.type);\n      if (!edgeData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.dropEdge: could not find the \\\"\".concat(source, \"\\\" -> \\\"\").concat(target, \"\\\" edge in the graph.\"));\n    } else {\n      edge = '' + edge;\n      edgeData = this._edges.get(edge);\n      if (!edgeData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.dropEdge: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    } // Dropping the edge from the register\n\n\n    this._edges[\"delete\"](edgeData.key); // Updating related degrees\n\n\n    var _edgeData = edgeData,\n        sourceData = _edgeData.source,\n        targetData = _edgeData.target,\n        attributes = _edgeData.attributes;\n    var undirected = edgeData instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"];\n\n    if (sourceData === targetData) {\n      sourceData.selfLoops--;\n    } else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      } else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    } // Clearing index\n\n\n    Object(_indices__WEBPACK_IMPORTED_MODULE_5__[\"clearEdgeFromStructureIndex\"])(this, undirected, edgeData);\n    if (undirected) this._undirectedSize--;else this._directedSize--; // Emitting\n\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes: attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected: undirected\n    });\n    return this;\n  }\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  ;\n\n  _proto.clear = function clear() {\n    // Clearing edges\n    this._edges.clear(); // Clearing nodes\n\n\n    this._nodes.clear(); // Emitting\n\n\n    this.emit('cleared');\n  }\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  ;\n\n  _proto.clearEdges = function clearEdges() {\n    // Clearing edges\n    this._edges.clear(); // Clearing indices\n\n\n    this.clearIndex(); // Emitting\n\n    this.emit('edgesCleared');\n  }\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  ;\n\n  _proto.getAttribute = function getAttribute(name) {\n    return this._attributes[name];\n  }\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  ;\n\n  _proto.getAttributes = function getAttributes() {\n    return this._attributes;\n  }\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  ;\n\n  _proto.hasAttribute = function hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  ;\n\n  _proto.setAttribute = function setAttribute(name, value) {\n    this._attributes[name] = value; // Emitting\n\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name: name,\n        value: value\n      }\n    });\n    return this;\n  }\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  ;\n\n  _proto.updateAttribute = function updateAttribute(name, updater) {\n    if (typeof updater !== 'function') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.updateAttribute: updater should be a function.');\n    this._attributes[name] = updater(this._attributes[name]); // Emitting\n\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name: name,\n        value: this._attributes[name]\n      }\n    });\n    return this;\n  }\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  ;\n\n  _proto.removeAttribute = function removeAttribute(name) {\n    delete this._attributes[name]; // Emitting\n\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      meta: {\n        name: name\n      }\n    });\n    return this;\n  }\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  ;\n\n  _proto.replaceAttributes = function replaceAttributes(attributes) {\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.replaceAttributes: provided attributes are not a plain object.');\n    var before = this._attributes;\n    this._attributes = attributes; // Emitting\n\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      meta: {\n        before: before,\n        after: attributes\n      }\n    });\n    return this;\n  }\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  ;\n\n  _proto.mergeAttributes = function mergeAttributes(attributes) {\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.mergeAttributes: provided attributes are not a plain object.');\n    this._attributes = Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])(this._attributes, attributes); // Emitting\n\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      meta: {\n        data: this._attributes\n      }\n    });\n    return this;\n  }\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  ;\n\n  _proto.getNodeAttribute = function getNodeAttribute(node, name) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.getNodeAttribute: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    return data.attributes[name];\n  }\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  ;\n\n  _proto.getNodeAttributes = function getNodeAttributes(node) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.getNodeAttributes: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    return data.attributes;\n  }\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  ;\n\n  _proto.hasNodeAttribute = function hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.hasNodeAttribute: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    return data.attributes.hasOwnProperty(name);\n  }\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  ;\n\n  _proto.setNodeAttribute = function setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.setNodeAttribute: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (arguments.length < 3) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n    data.attributes[name] = value; // Emitting\n\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name: name,\n        value: value\n      }\n    });\n    return this;\n  }\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  ;\n\n  _proto.updateNodeAttribute = function updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.updateNodeAttribute: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (arguments.length < 3) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n    if (typeof updater !== 'function') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.updateAttribute: updater should be a function.');\n    var attributes = data.attributes;\n    attributes[name] = updater(attributes[name]); // Emitting\n\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name: name,\n        value: attributes[name]\n      }\n    });\n    return this;\n  }\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  ;\n\n  _proto.removeNodeAttribute = function removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.hasNodeAttribute: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    delete data.attributes[name]; // Emitting\n\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      meta: {\n        name: name\n      }\n    });\n    return this;\n  }\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  ;\n\n  _proto.replaceNodeAttributes = function replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.replaceNodeAttributes: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n    var oldAttributes = data.attributes;\n    data.attributes = attributes; // Emitting\n\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n    return this;\n  }\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  ;\n\n  _proto.mergeNodeAttributes = function mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.mergeNodeAttributes: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])(data.attributes, attributes); // Emitting\n\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n    return this;\n  }\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  ;\n\n  _proto.forEach = function forEach(callback) {\n    if (typeof callback !== 'function') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.forEach: expecting a callback.');\n\n    this._edges.forEach(function (edgeData, key) {\n      var sourceData = edgeData.source,\n          targetData = edgeData.target;\n      callback(sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, key, edgeData.attributes);\n    });\n  }\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  ;\n\n  _proto.adjacency = function adjacency() {\n    var iterator = this._edges.values();\n\n    return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_1___default.a(function () {\n      var step = iterator.next();\n      if (step.done) return step;\n      var edgeData = step.value;\n      var sourceData = edgeData.source,\n          targetData = edgeData.target;\n      return {\n        done: false,\n        value: [sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.key, edgeData.attributes]\n      };\n    });\n  }\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  ;\n\n  _proto.nodes = function nodes() {\n    return obliterator_take__WEBPACK_IMPORTED_MODULE_2___default()(this._nodes.keys(), this._nodes.size);\n  }\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  ;\n\n  _proto.forEachNode = function forEachNode(callback) {\n    if (typeof callback !== 'function') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach(function (data, key) {\n      callback(key, data.attributes);\n    });\n  }\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  ;\n\n  _proto.nodeEntries = function nodeEntries() {\n    var iterator = this._nodes.values();\n\n    return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_1___default.a(function () {\n      var step = iterator.next();\n      if (step.done) return step;\n      var data = step.value;\n      return {\n        value: [data.key, data.attributes],\n        done: false\n      };\n    });\n  }\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  ;\n\n  _proto.exportNode = function exportNode(node) {\n    node = '' + node;\n\n    var data = this._nodes.get(node);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.exportNode: could not find the \\\"\".concat(node, \"\\\" node in the graph.\"));\n    return Object(_serialization__WEBPACK_IMPORTED_MODULE_9__[\"serializeNode\"])(node, data);\n  }\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  ;\n\n  _proto.exportEdge = function exportEdge(edge) {\n    edge = '' + edge;\n\n    var data = this._edges.get(edge);\n\n    if (!data) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.exportEdge: could not find the \\\"\".concat(edge, \"\\\" edge in the graph.\"));\n    return Object(_serialization__WEBPACK_IMPORTED_MODULE_9__[\"serializeEdge\"])(edge, data);\n  }\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  ;\n\n  _proto[\"export\"] = function _export() {\n    var nodes = new Array(this._nodes.size);\n    var i = 0;\n\n    this._nodes.forEach(function (data, key) {\n      nodes[i++] = Object(_serialization__WEBPACK_IMPORTED_MODULE_9__[\"serializeNode\"])(key, data);\n    });\n\n    var edges = new Array(this._edges.size);\n    i = 0;\n\n    this._edges.forEach(function (data, key) {\n      edges[i++] = Object(_serialization__WEBPACK_IMPORTED_MODULE_9__[\"serializeEdge\"])(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes: nodes,\n      edges: edges\n    };\n  }\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  ;\n\n  _proto.importNode = function importNode(data) {\n    var merge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // Validating\n    var error = Object(_serialization__WEBPACK_IMPORTED_MODULE_9__[\"validateSerializedNode\"])(data);\n\n    if (error) {\n      if (error === 'not-object') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    } // Adding the node\n\n\n    var key = data.key,\n        _data$attributes = data.attributes,\n        attributes = _data$attributes === void 0 ? {} : _data$attributes;\n    if (merge) this.mergeNode(key, attributes);else this.addNode(key, attributes);\n    return this;\n  }\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  ;\n\n  _proto.importEdge = function importEdge(data) {\n    var merge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // Validating\n    var error = Object(_serialization__WEBPACK_IMPORTED_MODULE_9__[\"validateSerializedEdge\"])(data);\n\n    if (error) {\n      if (error === 'not-object') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importEdge: missing souce.');\n      if (error === 'no-target') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    } // Adding the edge\n\n\n    var source = data.source,\n        target = data.target,\n        _data$attributes2 = data.attributes,\n        attributes = _data$attributes2 === void 0 ? {} : _data$attributes2,\n        _data$undirected = data.undirected,\n        undirected = _data$undirected === void 0 ? false : _data$undirected;\n    var method;\n\n    if ('key' in data) {\n      method = merge ? undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey;\n      method.call(this, data.key, source, target, attributes);\n    } else {\n      method = merge ? undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge : undirected ? this.addUndirectedEdge : this.addDirectedEdge;\n      method.call(this, source, target, attributes);\n    }\n\n    return this;\n  }\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  ;\n\n  _proto[\"import\"] = function _import(data) {\n    var _this2 = this;\n\n    var merge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // Importing a Graph instance\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isGraph\"])(data)) {\n      this[\"import\"](data[\"export\"](), merge);\n      return this;\n    } // Importing a serialized graph\n\n\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(data)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"isPlainObject\"])(data.attributes)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"]('Graph.import: invalid attributes. Expecting a plain object.');\n      if (merge) this.mergeAttributes(data.attributes);else this.replaceAttributes(data.attributes);\n    } // TODO: optimize\n\n\n    if (data.nodes) data.nodes.forEach(function (node) {\n      return _this2.importNode(node, merge);\n    });\n    if (data.edges) data.edges.forEach(function (edge) {\n      return _this2.importEdge(edge, merge);\n    });\n    return this;\n  }\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  ;\n\n  _proto.nullCopy = function nullCopy(options) {\n    return new Graph(Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])({}, this._options, options));\n  }\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  ;\n\n  _proto.emptyCopy = function emptyCopy(options) {\n    var graph = new Graph(Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])({}, this._options, options));\n\n    this._nodes.forEach(function (nodeData, key) {\n      nodeData = new graph.NodeDataClass(key, Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"assign\"])({}, nodeData.attributes));\n\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  ;\n\n  _proto.copy = function copy() {\n    var graph = new Graph(this._options);\n    graph[\"import\"](this);\n    return graph;\n  }\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  ;\n\n  _proto.upgradeToMixed = function upgradeToMixed() {\n    if (this.type === 'mixed') return this; // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n\n    this._nodes.forEach(function (data) {\n      return data.upgradeToMixed();\n    }); // Mutating the options & the instance\n\n\n    this._options.type = 'mixed';\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(this, 'type', this._options.type);\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(this, 'NodeDataClass', _data__WEBPACK_IMPORTED_MODULE_4__[\"MixedNodeData\"]);\n    return this;\n  }\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  ;\n\n  _proto.upgradeToMulti = function upgradeToMulti() {\n    if (this.multi) return this; // Mutating the options & the instance\n\n    this._options.multi = true;\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"readOnlyProperty\"])(this, 'multi', true); // Upgrading indices\n\n    Object(_indices__WEBPACK_IMPORTED_MODULE_5__[\"upgradeStructureIndexToMulti\"])(this);\n    return this;\n  }\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  ;\n\n  _proto.clearIndex = function clearIndex() {\n    Object(_indices__WEBPACK_IMPORTED_MODULE_5__[\"clearStructureIndex\"])(this);\n    return this;\n  }\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  ;\n\n  _proto.toJSON = function toJSON() {\n    return this[\"export\"]();\n  }\n  /**\n   * Method used to perform string coercion and returning useful information\n   * about the Graph instance.\n   *\n   * @return {string} - String representation of the graph.\n   */\n  ;\n\n  _proto.toString = function toString() {\n    var pluralOrder = this.order > 1 || this.order === 0,\n        pluralSize = this.size > 1 || this.size === 0;\n    return \"Graph<\".concat(Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"prettyPrint\"])(this.order), \" node\").concat(pluralOrder ? 's' : '', \", \").concat(Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"prettyPrint\"])(this.size), \" edge\").concat(pluralSize ? 's' : '', \">\");\n  }\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  ;\n\n  _proto.inspect = function inspect() {\n    var _this3 = this;\n\n    var nodes = {};\n\n    this._nodes.forEach(function (data, key) {\n      nodes[key] = data.attributes;\n    });\n\n    var edges = {},\n        multiIndex = {};\n\n    this._edges.forEach(function (data, key) {\n      var direction = data instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"] ? '--' : '->';\n      var label = '';\n      var desc = \"(\".concat(data.source.key, \")\").concat(direction, \"(\").concat(data.target.key, \")\");\n\n      if (!data.generatedKey) {\n        label += \"[\".concat(key, \"]: \");\n      } else if (_this3.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += \"\".concat(multiIndex[desc], \". \");\n      }\n\n      label += desc;\n      edges[label] = data.attributes;\n    });\n\n    var dummy = {};\n\n    for (var k in this) {\n      if (this.hasOwnProperty(k) && !EMITTER_PROPS.has(k) && typeof this[k] !== 'function') dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n    Object(_utils__WEBPACK_IMPORTED_MODULE_10__[\"privateProperty\"])(dummy, 'constructor', this.constructor);\n    return dummy;\n  };\n\n  return Graph;\n}(events__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter\"]);\n/**\n * Attaching custom inspect method for node >= 10.\n */\n\n\n\nif (typeof Symbol !== 'undefined') Graph.prototype[Symbol[\"for\"]('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\n\nEDGE_ADD_METHODS.forEach(function (method) {\n  ['add', 'merge'].forEach(function (verb) {\n    var name = method.name(verb),\n        fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(this, name, true, (method.type || this.type) === 'undirected', null, source, target, attributes);\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(this, name, false, (method.type || this.type) === 'undirected', edge, source, target, attributes);\n      };\n    }\n  });\n});\n/**\n * Self iterator.\n */\n\nif (typeof Symbol !== 'undefined') Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n/**\n * Attributes-related.\n */\n\nObject(_attributes__WEBPACK_IMPORTED_MODULE_6__[\"attachAttributesMethods\"])(Graph);\n/**\n * Edge iteration-related.\n */\n\nObject(_iteration_edges__WEBPACK_IMPORTED_MODULE_7__[\"attachEdgeIterationMethods\"])(Graph);\n/**\n * Neighbor iteration-related.\n */\n\nObject(_iteration_neighbors__WEBPACK_IMPORTED_MODULE_8__[\"attachNeighborIterationMethods\"])(Graph);\n\n//# sourceURL=webpack://graphology/./src/graph.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph */ \"./src/graph.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * Graphology Reference Implementation Endoint\n * ============================================\n *\n * Importing the Graph object & creating typed constructors.\n */\n\n\n\n/**\n * Alternative constructors.\n */\n\nvar DirectedGraph =\n/*#__PURE__*/\nfunction (_Graph) {\n  _inheritsLoose(DirectedGraph, _Graph);\n\n  function DirectedGraph(options) {\n    return _Graph.call(this, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])({\n      type: 'directed'\n    }, options)) || this;\n  }\n\n  return DirectedGraph;\n}(_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\nvar UndirectedGraph =\n/*#__PURE__*/\nfunction (_Graph2) {\n  _inheritsLoose(UndirectedGraph, _Graph2);\n\n  function UndirectedGraph(options) {\n    return _Graph2.call(this, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])({\n      type: 'undirected'\n    }, options)) || this;\n  }\n\n  return UndirectedGraph;\n}(_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\nvar MultiGraph =\n/*#__PURE__*/\nfunction (_Graph3) {\n  _inheritsLoose(MultiGraph, _Graph3);\n\n  function MultiGraph(options) {\n    return _Graph3.call(this, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])({\n      multi: true\n    }, options)) || this;\n  }\n\n  return MultiGraph;\n}(_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\nvar MultiDirectedGraph =\n/*#__PURE__*/\nfunction (_Graph4) {\n  _inheritsLoose(MultiDirectedGraph, _Graph4);\n\n  function MultiDirectedGraph(options) {\n    return _Graph4.call(this, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])({\n      multi: true,\n      type: 'directed'\n    }, options)) || this;\n  }\n\n  return MultiDirectedGraph;\n}(_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\nvar MultiUndirectedGraph =\n/*#__PURE__*/\nfunction (_Graph5) {\n  _inheritsLoose(MultiUndirectedGraph, _Graph5);\n\n  function MultiUndirectedGraph(options) {\n    return _Graph5.call(this, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])({\n      multi: true,\n      type: 'undirected'\n    }, options)) || this;\n  }\n\n  return MultiUndirectedGraph;\n}(_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/**\n * Attaching static #.from method to each of the constructors.\n */\n\n\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    var instance = new Class(options);\n    instance[\"import\"](data);\n    return instance;\n  };\n}\n\nattachStaticFromMethod(_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n/**\n * Attaching the various constructors to the Graph class itself so we can\n * keep CommonJS semantics so everyone can consume the library easily.\n */\n\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Graph = _graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].DirectedGraph = DirectedGraph;\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].UndirectedGraph = UndirectedGraph;\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].MultiGraph = MultiGraph;\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].MultiDirectedGraph = MultiDirectedGraph;\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].MultiUndirectedGraph = MultiUndirectedGraph;\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].InvalidArgumentsGraphError = _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidArgumentsGraphError\"];\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NotFoundGraphError = _errors__WEBPACK_IMPORTED_MODULE_2__[\"NotFoundGraphError\"];\n_graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"].UsageGraphError = _errors__WEBPACK_IMPORTED_MODULE_2__[\"UsageGraphError\"];\nmodule.exports = _graph__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack://graphology/./src/index.js?");

/***/ }),

/***/ "./src/indices.js":
/*!************************!*\
  !*** ./src/indices.js ***!
  \************************/
/*! exports provided: updateStructureIndex, clearEdgeFromStructureIndex, clearStructureIndex, upgradeStructureIndexToMulti */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateStructureIndex\", function() { return updateStructureIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearEdgeFromStructureIndex\", function() { return clearEdgeFromStructureIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearStructureIndex\", function() { return clearStructureIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upgradeStructureIndexToMulti\", function() { return upgradeStructureIndexToMulti; });\n/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nfunction updateStructureIndex(graph, undirected, edgeData, source, target, sourceData, targetData) {\n  var multi = graph.multi;\n  var outKey = undirected ? 'undirected' : 'out',\n      inKey = undirected ? 'undirected' : 'in'; // Handling source\n\n  var edgeOrSet = sourceData[outKey][target];\n\n  if (typeof edgeOrSet === 'undefined') {\n    edgeOrSet = multi ? new Set() : edgeData;\n    sourceData[outKey][target] = edgeOrSet;\n  }\n\n  if (multi) edgeOrSet.add(edgeData); // If selfLoop, we break here\n\n  if (source === target) return; // Handling target (we won't add the edge because it was already taken\n  // care of with source above)\n\n  if (typeof targetData[inKey][source] === 'undefined') targetData[inKey][source] = edgeOrSet;\n}\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\n\nfunction clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  var multi = graph.multi;\n  var sourceData = edgeData.source,\n      targetData = edgeData.target;\n  var source = sourceData.key,\n      target = targetData.key; // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n\n  var outKey = undirected ? 'undirected' : 'out',\n      sourceIndex = sourceData[outKey];\n  var inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n    if (multi) {\n      var set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      } else {\n        set[\"delete\"](edgeData);\n      }\n    } else delete sourceIndex[target];\n  }\n\n  if (multi) return;\n  var targetIndex = targetData[inKey];\n  delete targetIndex[source];\n}\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\n\nfunction clearStructureIndex(graph) {\n  graph._nodes.forEach(function (data) {\n    // Clearing now useless properties\n    if (typeof data[\"in\"] !== 'undefined') {\n      data[\"in\"] = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\n\nfunction upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach(function (data, node) {\n    // Directed\n    if (data.out) {\n      for (var neighbor in data.out) {\n        var edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor)[\"in\"][node] = edges;\n      }\n    } // Undirected\n\n\n    if (data.undirected) {\n      for (var _neighbor in data.undirected) {\n        if (_neighbor > node) continue;\n\n        var _edges = new Set();\n\n        _edges.add(data.undirected[_neighbor]);\n\n        data.undirected[_neighbor] = _edges;\n        graph._nodes.get(_neighbor).undirected[node] = _edges;\n      }\n    }\n  });\n}\n\n//# sourceURL=webpack://graphology/./src/indices.js?");

/***/ }),

/***/ "./src/iteration/edges.js":
/*!********************************!*\
  !*** ./src/iteration/edges.js ***!
  \********************************/
/*! exports provided: attachEdgeIteratorCreator, attachEdgeIterationMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachEdgeIteratorCreator\", function() { return attachEdgeIteratorCreator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachEdgeIterationMethods\", function() { return attachEdgeIterationMethods; });\n/* harmony import */ var obliterator_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! obliterator/iterator */ \"./node_modules/obliterator/iterator.js\");\n/* harmony import */ var obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(obliterator_iterator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var obliterator_chain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! obliterator/chain */ \"./node_modules/obliterator/chain.js\");\n/* harmony import */ var obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(obliterator_chain__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var obliterator_take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! obliterator/take */ \"./node_modules/obliterator/take.js\");\n/* harmony import */ var obliterator_take__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(obliterator_take__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data */ \"./src/data.js\");\n/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\n\n\n\n\n\n/**\n * Definitions.\n */\n\nvar EDGES_ITERATION = [{\n  name: 'edges',\n  type: 'mixed'\n}, {\n  name: 'inEdges',\n  type: 'directed',\n  direction: 'in'\n}, {\n  name: 'outEdges',\n  type: 'directed',\n  direction: 'out'\n}, {\n  name: 'inboundEdges',\n  type: 'mixed',\n  direction: 'in'\n}, {\n  name: 'outboundEdges',\n  type: 'mixed',\n  direction: 'out'\n}, {\n  name: 'directedEdges',\n  type: 'directed'\n}, {\n  name: 'undirectedEdges',\n  type: 'undirected'\n}];\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\n\nfunction collect(edges, object) {\n  for (var k in object) {\n    if (object[k] instanceof Set) object[k].forEach(function (edgeData) {\n      return edges.push(edgeData.key);\n    });else edges.push(object[k].key);\n  }\n}\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\n\n\nfunction forEach(object, callback) {\n  for (var k in object) {\n    if (object[k] instanceof Set) object[k].forEach(function (edgeData) {\n      return callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes);\n    });else {\n      var edgeData = object[k];\n      callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes);\n    }\n  }\n}\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\n\n\nfunction createIterator(object) {\n  var keys = Object.keys(object),\n      l = keys.length;\n  var inner = null,\n      i = 0;\n  return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a(function next() {\n    var edgeData;\n\n    if (inner) {\n      var step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    } else {\n      if (i >= l) return {\n        done: true\n      };\n      var k = keys[i];\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes]\n    };\n  });\n}\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\n\n\nfunction collectForKey(edges, object, k) {\n  if (!(k in object)) return;\n  if (object[k] instanceof Set) object[k].forEach(function (edgeData) {\n    return edges.push(edgeData.key);\n  });else edges.push(object[k].key);\n  return;\n}\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\n\n\nfunction forEachForKey(object, k, callback) {\n  if (!(k in object)) return;\n  if (object[k] instanceof Set) object[k].forEach(function (edgeData) {\n    return callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes);\n  });else {\n    var edgeData = object[k];\n    callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes);\n  }\n  return;\n}\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\n\n\nfunction createIteratorForKey(object, k) {\n  var v = object[k];\n\n  if (v instanceof Set) {\n    var iterator = v.values();\n    return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a(function () {\n      var step = iterator.next();\n      if (step.done) return step;\n      var edgeData = step.value;\n      return {\n        done: false,\n        value: [edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes]\n      };\n    });\n  }\n\n  return obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a.of([v.key, v.attributes, v.source.key, v.target.key, v.source.attributes, v.target.attributes]);\n}\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\n\n\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n  if (type === 'mixed' || type === graph.type) return obliterator_take__WEBPACK_IMPORTED_MODULE_2___default()(graph._edges.keys(), graph._edges.size);\n  var size = type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n  var list = new Array(size),\n      mask = type === 'undirected';\n  var i = 0;\n\n  graph._edges.forEach(function (data, edge) {\n    if (data instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"] === mask) list[i++] = edge;\n  });\n\n  return list;\n}\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\n\n\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0) return;\n\n  if (type === 'mixed' || type === graph.type) {\n    graph._edges.forEach(function (data, key) {\n      var attributes = data.attributes,\n          source = data.source,\n          target = data.target;\n      callback(key, attributes, source.key, target.key, source.attributes, target.attributes);\n    });\n  } else {\n    var mask = type === 'undirected';\n\n    graph._edges.forEach(function (data, key) {\n      if (data instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"] === mask) {\n        var attributes = data.attributes,\n            source = data.source,\n            target = data.target;\n        callback(key, attributes, source.key, target.key, source.attributes, target.attributes);\n      }\n    });\n  }\n}\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\n\n\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a.empty();\n  var iterator;\n\n  if (type === 'mixed') {\n    iterator = graph._edges.values();\n    return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a(function next() {\n      var step = iterator.next();\n      if (step.done) return step;\n      var data = step.value;\n      var value = [data.key, data.attributes, data.source.key, data.target.key, data.source.attributes, data.target.attributes];\n      return {\n        value: value,\n        done: false\n      };\n    });\n  }\n\n  iterator = graph._edges.values();\n  return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a(function next() {\n    var step = iterator.next();\n    if (step.done) return step;\n    var data = step.value;\n\n    if (data instanceof _data__WEBPACK_IMPORTED_MODULE_4__[\"UndirectedEdgeData\"] === (type === 'undirected')) {\n      var value = [data.key, data.attributes, data.source.key, data.target.key, data.source.attributes, data.target.attributes];\n      return {\n        value: value,\n        done: false\n      };\n    }\n\n    return next();\n  });\n}\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\n\n\nfunction createEdgeArrayForNode(type, direction, nodeData) {\n  var edges = [];\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') collect(edges, nodeData[\"in\"]);\n    if (direction !== 'in') collect(edges, nodeData.out);\n  }\n\n  if (type !== 'directed') {\n    collect(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\n\n\nfunction forEachEdgeForNode(type, direction, nodeData, callback) {\n  if (type !== 'undirected') {\n    if (direction !== 'out') forEach(nodeData[\"in\"], callback);\n    if (direction !== 'in') forEach(nodeData.out, callback);\n  }\n\n  if (type !== 'directed') {\n    forEach(nodeData.undirected, callback);\n  }\n}\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\n\n\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  var iterator = obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData[\"in\"] !== 'undefined') iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createIterator(nodeData[\"in\"]));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createIterator(nodeData.out));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\n\n\nfunction createEdgeArrayForPath(type, direction, sourceData, target) {\n  var edges = [];\n\n  if (type !== 'undirected') {\n    if (typeof sourceData[\"in\"] !== 'undefined' && direction !== 'out') collectForKey(edges, sourceData[\"in\"], target);\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in') collectForKey(edges, sourceData.out, target);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') collectForKey(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\n\n\nfunction forEachEdgeForPath(type, direction, sourceData, target, callback) {\n  if (type !== 'undirected') {\n    if (typeof sourceData[\"in\"] !== 'undefined' && direction !== 'out') forEachForKey(sourceData[\"in\"], target, callback);\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in') forEachForKey(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') forEachForKey(sourceData.undirected, target, callback);\n  }\n}\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\n\n\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  var iterator = obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a.empty();\n\n  if (type !== 'undirected') {\n    if (typeof sourceData[\"in\"] !== 'undefined' && direction !== 'out' && target in sourceData[\"in\"]) iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createIteratorForKey(sourceData[\"in\"], target));\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in' && target in sourceData.out) iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined' && target in sourceData.undirected) iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\n\n\nfunction attachEdgeArrayCreator(Class, description) {\n  var name = description.name,\n      type = description.type,\n      direction = description.direction;\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return [];\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      var nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \": could not find the \\\"\").concat(source, \"\\\" node in the graph.\")); // Iterating over a node's edges\n\n      return createEdgeArrayForNode(type === 'mixed' ? this.type : type, direction, nodeData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      var sourceData = this._nodes.get(source);\n\n      if (!sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \":  could not find the \\\"\").concat(source, \"\\\" source node in the graph.\"));\n      if (!this._nodes.has(target)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \":  could not find the \\\"\").concat(target, \"\\\" target node in the graph.\")); // Iterating over the edges between source & target\n\n      return createEdgeArrayForPath(type, direction, sourceData, target);\n    }\n\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(name, \": too many arguments (expecting 0, 1 or 2 and got \").concat(arguments.length, \").\"));\n  };\n}\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\n\n\nfunction attachForEachEdge(Class, description) {\n  var name = description.name,\n      type = description.type,\n      direction = description.direction;\n  var forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      var nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(forEachName, \": could not find the \\\"\").concat(source, \"\\\" node in the graph.\")); // Iterating over a node's edges\n\n      return forEachEdgeForNode(type === 'mixed' ? this.type : type, direction, nodeData, callback);\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      var sourceData = this._nodes.get(source);\n\n      if (!sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(forEachName, \":  could not find the \\\"\").concat(source, \"\\\" source node in the graph.\"));\n      if (!this._nodes.has(target)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(forEachName, \":  could not find the \\\"\").concat(target, \"\\\" target node in the graph.\")); // Iterating over the edges between source & target\n\n      return forEachEdgeForPath(type, direction, sourceData, target, callback);\n    }\n\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(forEachName, \": too many arguments (expecting 1, 2 or 3 and got \").concat(arguments.length, \").\"));\n  };\n}\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\n\n\nfunction attachEdgeIteratorCreator(Class, description) {\n  var originalName = description.name,\n      type = description.type,\n      direction = description.direction;\n  var name = originalName.slice(0, -1) + 'Entries';\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a.empty();\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      var sourceData = this._nodes.get(source);\n\n      if (!sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \": could not find the \\\"\").concat(source, \"\\\" node in the graph.\")); // Iterating over a node's edges\n\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      var _sourceData = this._nodes.get(source);\n\n      if (!_sourceData) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \":  could not find the \\\"\").concat(source, \"\\\" source node in the graph.\"));\n      if (!this._nodes.has(target)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \":  could not find the \\\"\").concat(target, \"\\\" target node in the graph.\")); // Iterating over the edges between source & target\n\n      return createEdgeIteratorForPath(type, direction, _sourceData, target);\n    }\n\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(name, \": too many arguments (expecting 0, 1 or 2 and got \").concat(arguments.length, \").\"));\n  };\n}\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\n\nfunction attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(function (description) {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n\n//# sourceURL=webpack://graphology/./src/iteration/edges.js?");

/***/ }),

/***/ "./src/iteration/neighbors.js":
/*!************************************!*\
  !*** ./src/iteration/neighbors.js ***!
  \************************************/
/*! exports provided: attachNeighborIterationMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachNeighborIterationMethods\", function() { return attachNeighborIterationMethods; });\n/* harmony import */ var obliterator_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! obliterator/iterator */ \"./node_modules/obliterator/iterator.js\");\n/* harmony import */ var obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(obliterator_iterator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var obliterator_chain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! obliterator/chain */ \"./node_modules/obliterator/chain.js\");\n/* harmony import */ var obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(obliterator_chain__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var obliterator_take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! obliterator/take */ \"./node_modules/obliterator/take.js\");\n/* harmony import */ var obliterator_take__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(obliterator_take__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\n/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\n\n\n\n\n/**\n * Definitions.\n */\n\nvar NEIGHBORS_ITERATION = [{\n  name: 'neighbors',\n  type: 'mixed'\n}, {\n  name: 'inNeighbors',\n  type: 'directed',\n  direction: 'in'\n}, {\n  name: 'outNeighbors',\n  type: 'directed',\n  direction: 'out'\n}, {\n  name: 'inboundNeighbors',\n  type: 'mixed',\n  direction: 'in'\n}, {\n  name: 'outboundNeighbors',\n  type: 'mixed',\n  direction: 'out'\n}, {\n  name: 'directedNeighbors',\n  type: 'directed'\n}, {\n  name: 'undirectedNeighbors',\n  type: 'undirected'\n}];\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\n\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined') return;\n\n  for (var neighbor in object) {\n    neighbors.add(neighbor);\n  }\n}\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\n\n\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  } // Else we need to keep a set of neighbors not to return duplicates\n\n\n  var neighbors = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      merge(neighbors, nodeData[\"in\"]);\n    }\n\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return obliterator_take__WEBPACK_IMPORTED_MODULE_2___default()(neighbors.values(), neighbors.size);\n}\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\n\n\nfunction forEachInObject(nodeData, object, callback) {\n  for (var k in object) {\n    var edgeData = object[k];\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n    var sourceData = edgeData.source,\n        targetData = edgeData.target;\n    var neighborData = sourceData === nodeData ? targetData : sourceData;\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (var k in object) {\n    var edgeData = object[k];\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n    var sourceData = edgeData.source,\n        targetData = edgeData.target;\n    var neighborData = sourceData === nodeData ? targetData : sourceData;\n    if (visited.has(neighborData.key)) continue;\n    visited.add(neighborData.key);\n    callback(neighborData.key, neighborData.attributes);\n  }\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return forEachInObject(nodeData, nodeData.undirected, callback);\n    if (typeof direction === 'string') return forEachInObject(nodeData, nodeData[direction], callback);\n  } // Else we need to keep a set of neighbors not to return duplicates\n\n\n  var visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData[\"in\"], callback);\n    }\n\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\n\n\nfunction createObjectIterator(nodeData, object) {\n  var keys = Object.keys(object),\n      l = keys.length;\n  var i = 0;\n  return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var edgeData = object[keys[i++]];\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n    var sourceData = edgeData.source,\n        targetData = edgeData.target;\n    var neighborData = sourceData === nodeData ? targetData : sourceData;\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  var keys = Object.keys(object),\n      l = keys.length;\n  var i = 0;\n  return new obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a(function next() {\n    if (i >= l) return {\n      done: true\n    };\n    var edgeData = object[keys[i++]];\n    if (edgeData instanceof Set) edgeData = edgeData.values().next().value;\n    var sourceData = edgeData.source,\n        targetData = edgeData.target;\n    var neighborData = sourceData === nodeData ? targetData : sourceData;\n    if (visited.has(neighborData.key)) return next();\n    visited.add(neighborData.key);\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return createObjectIterator(nodeData, nodeData.undirected);\n    if (typeof direction === 'string') return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  var iterator = obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a.empty(); // Else we need to keep a set of neighbors not to return duplicates\n\n  var visited = new Set();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createDedupedObjectIterator(visited, nodeData, nodeData[\"in\"]));\n    }\n\n    if (direction !== 'in') {\n      iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = obliterator_chain__WEBPACK_IMPORTED_MODULE_1___default()(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\n\n\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n  var nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData[\"in\"] !== 'undefined') {\n      for (var k in nodeData[\"in\"]) {\n        if (k === neighbor) return true;\n      }\n    }\n\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (var _k in nodeData.out) {\n        if (_k === neighbor) return true;\n      }\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (var _k2 in nodeData.undirected) {\n      if (_k2 === neighbor) return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\n\n\nfunction attachNeighborArrayCreator(Class, description) {\n  var name = description.name,\n      type = description.type,\n      direction = description.direction;\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return [];\n\n    if (arguments.length === 2) {\n      var node1 = '' + arguments[0],\n          node2 = '' + arguments[1];\n      if (!this._nodes.has(node1)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \": could not find the \\\"\").concat(node1, \"\\\" node in the graph.\"));\n      if (!this._nodes.has(node2)) throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \": could not find the \\\"\").concat(node2, \"\\\" node in the graph.\")); // Here, we want to assess whether the two given nodes are neighbors\n\n      return nodeHasNeighbor(this, type, direction, node1, node2);\n    } else if (arguments.length === 1) {\n      node = '' + node;\n\n      var nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(name, \": could not find the \\\"\").concat(node, \"\\\" node in the graph.\")); // Here, we want to iterate over a node's relevant neighbors\n\n      var neighbors = createNeighborArrayForNode(type === 'mixed' ? this.type : type, direction, nodeData);\n      return neighbors;\n    }\n\n    throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"InvalidArgumentsGraphError\"](\"Graph.\".concat(name, \": invalid number of arguments (expecting 1 or 2 and got \").concat(arguments.length, \").\"));\n  };\n}\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\n\n\nfunction attachForEachNeighbor(Class, description) {\n  var name = description.name,\n      type = description.type,\n      direction = description.direction;\n  var forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n    node = '' + node;\n\n    var nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(forEachName, \": could not find the \\\"\").concat(node, \"\\\" node in the graph.\")); // Here, we want to iterate over a node's relevant neighbors\n\n    forEachNeighborForNode(type === 'mixed' ? this.type : type, direction, nodeData, callback);\n  };\n}\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\n\n\nfunction attachNeighborIteratorCreator(Class, description) {\n  var name = description.name,\n      type = description.type,\n      direction = description.direction;\n  var iteratorName = name.slice(0, -1) + 'Entries';\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return obliterator_iterator__WEBPACK_IMPORTED_MODULE_0___default.a.empty();\n    node = '' + node;\n\n    var nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined') throw new _errors__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundGraphError\"](\"Graph.\".concat(iteratorName, \": could not find the \\\"\").concat(node, \"\\\" node in the graph.\")); // Here, we want to iterate over a node's relevant neighbors\n\n    return createNeighborIterator(type === 'mixed' ? this.type : type, direction, nodeData);\n  };\n}\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\n\n\nfunction attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(function (description) {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n\n//# sourceURL=webpack://graphology/./src/iteration/neighbors.js?");

/***/ }),

/***/ "./src/serialization.js":
/*!******************************!*\
  !*** ./src/serialization.js ***!
  \******************************/
/*! exports provided: serializeNode, serializeEdge, validateSerializedNode, validateSerializedEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serializeNode\", function() { return serializeNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serializeEdge\", function() { return serializeEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateSerializedNode\", function() { return validateSerializedNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateSerializedEdge\", function() { return validateSerializedEdge; });\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ \"./src/data.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\n\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\n\nfunction serializeNode(key, data) {\n  var serialized = {\n    key: key\n  };\n  if (Object.keys(data.attributes).length) serialized.attributes = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"assign\"])({}, data.attributes);\n  return serialized;\n}\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\n\nfunction serializeEdge(key, data) {\n  var serialized = {\n    source: data.source.key,\n    target: data.target.key\n  }; // We export the key unless if it was provided by the user\n\n  if (!data.generatedKey) serialized.key = key;\n  if (Object.keys(data.attributes).length) serialized.attributes = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"assign\"])({}, data.attributes);\n  if (data instanceof _data__WEBPACK_IMPORTED_MODULE_0__[\"UndirectedEdgeData\"]) serialized.undirected = true;\n  return serialized;\n}\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\n\nfunction validateSerializedNode(value) {\n  if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"isPlainObject\"])(value)) return 'not-object';\n  if (!('key' in value)) return 'no-key';\n  if ('attributes' in value && (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"isPlainObject\"])(value.attributes) || value.attributes === null)) return 'invalid-attributes';\n  return null;\n}\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\n\nfunction validateSerializedEdge(value) {\n  if (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"isPlainObject\"])(value)) return 'not-object';\n  if (!('source' in value)) return 'no-source';\n  if (!('target' in value)) return 'no-target';\n  if ('attributes' in value && (!Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"isPlainObject\"])(value.attributes) || value.attributes === null)) return 'invalid-attributes';\n  if ('undirected' in value && typeof value.undirected !== 'boolean') return 'invalid-undirected';\n  return null;\n}\n\n//# sourceURL=webpack://graphology/./src/serialization.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: assign, getMatchingEdge, isGraph, isPlainObject, prettyPrint, privateProperty, readOnlyProperty, incrementalId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatchingEdge\", function() { return getMatchingEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isGraph\", function() { return isGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return isPlainObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prettyPrint\", function() { return prettyPrint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"privateProperty\", function() { return privateProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"readOnlyProperty\", function() { return readOnlyProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"incrementalId\", function() { return incrementalId; });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assign() {\n  var target = arguments[0] || {};\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (var k in arguments[i]) {\n      target[k] = arguments[i][k];\n    }\n  }\n\n  return target;\n}\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\n\nfunction getMatchingEdge(graph, source, target, type) {\n  var sourceData = graph._nodes.get(source);\n\n  var edge = null;\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target];\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\n\nfunction isGraph(value) {\n  return value !== null && _typeof(value) === 'object' && typeof value.addUndirectedEdgeWithKey === 'function' && typeof value.dropNode === 'function';\n}\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\n\nfunction isPlainObject(value) {\n  return _typeof(value) === 'object' && value !== null && value.constructor === Object;\n}\n/**\n * Pretty prints the given integer.\n *\n * @param  {number}  integer - Target integer.\n * @return {string}          - The pretty string.\n */\n\nfunction prettyPrint(integer) {\n  var string = '' + integer;\n  var prettyString = '';\n\n  for (var i = 0, l = string.length; i < l; i++) {\n    var j = l - i - 1;\n    prettyString = string[j] + prettyString;\n    if (!((i - 2) % 3) && i !== l - 1) prettyString = ',' + prettyString;\n  }\n\n  return prettyString;\n}\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\n\nfunction privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value: value\n  });\n}\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\n\nfunction readOnlyProperty(target, name, value) {\n  var descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\n\nfunction incrementalId() {\n  var i = 0;\n  return function () {\n    return \"_geid\".concat(i++, \"_\");\n  };\n}\n\n//# sourceURL=webpack://graphology/./src/utils.js?");

/***/ })

/******/ });
});